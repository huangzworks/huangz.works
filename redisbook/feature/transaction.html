

<!DOCTYPE html>

<html lang="zh-cn" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>事务 &#8212; RedisBookOrigin 1.0 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/cloud.css?v=f9ae72be" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" href="../" type="text/css" />
    
    <script src="../_static/documentation_options.js?v=27ad66bf"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>

    
    
     
        <script src="../_static/cloud.base.js"></script>
    

    
     
        <script src="../_static/cloud.js"></script>
    

    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="订阅与发布" href="pubsub.html" />
    <link rel="prev" title="有序集" href="../datatype/sorted_set.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="pubsub.html" title="订阅与发布"
             accesskey="N">下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../datatype/sorted_set.html" title="有序集"
             accesskey="P">上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">RedisBookOrigin 1.0 文档</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">事务</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="id1">
<h1>事务<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p>Redis 通过 <span class="xref std std-ref">MULTI</span> 、 <span class="xref std std-ref">DISCARD</span> 、 <span class="xref std std-ref">EXEC</span> 和 <span class="xref std std-ref">WATCH</span> 四个命令来实现事务功能，
本章首先讨论使用 <span class="xref std std-ref">MULTI</span> 、 <span class="xref std std-ref">DISCARD</span> 和 <span class="xref std std-ref">EXEC</span> 三个命令实现的一般事务，
然后再来讨论带有 <span class="xref std std-ref">WATCH</span> 的事务的实现。</p>
<p>因为事务的安全性也非常重要，
所以本章最后通过常见的 ACID 性质对 Redis 事务的安全性进行了说明。</p>
<section id="id2">
<h2>事务<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p>事务提供了一种“将多个命令打包，
然后一次性、按顺序地执行”的机制，
并且事务在执行的期间不会主动中断 ——
服务器在执行完事务中的所有命令之后，
才会继续处理其他客户端的其他命令。</p>
<p>以下是一个事务的例子，
它先以 <span class="xref std std-ref">MULTI</span> 开始一个事务，
然后将多个命令入队到事务中，
最后由 <span class="xref std std-ref">EXEC</span> 命令触发事务，
一并执行事务中的所有命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;Mastering C++ in 21 days&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">tag</span> <span class="s2">&quot;C++&quot;</span> <span class="s2">&quot;Programming&quot;</span> <span class="s2">&quot;Mastering Series&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">tag</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="mi">1</span><span class="p">)</span> <span class="n">OK</span>
<span class="mi">2</span><span class="p">)</span> <span class="s2">&quot;Mastering C++ in 21 days&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">3</span>
<span class="mi">4</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="s2">&quot;Mastering Series&quot;</span>
   <span class="mi">2</span><span class="p">)</span> <span class="s2">&quot;C++&quot;</span>
   <span class="mi">3</span><span class="p">)</span> <span class="s2">&quot;Programming&quot;</span>
</pre></div>
</div>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol class="arabic simple">
<li><p>开始事务。</p></li>
<li><p>命令入队。</p></li>
<li><p>执行事务。</p></li>
</ol>
<p>下文将分别介绍事务的这三个阶段。</p>
</section>
<section id="id3">
<h2>开始事务<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p><span class="xref std std-ref">MULTI</span> 命令的执行标记着事务的开始：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>
</pre></div>
</div>
<p>这个命令唯一做的就是，
将客户端的 <code class="docutils literal notranslate"><span class="pre">REDIS_MULTI</span></code> 选项打开，
让客户端从非事务状态切换到事务状态。</p>
<div class="graphviz"><img src="../_images/graphviz-6678d70f6f554015edcf26991e8595d1dc29e00c.png" alt="digraph normal_to_transaction {

    rankdir = LR;

    node [shape = circle, style = filled];

    edge [style = bold];

    label = &quot;客户端状态的切换&quot;;

    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];

    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];

    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];
}" class="graphviz" /></div>
</section>
<section id="id4">
<h2>命令入队<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p>当客户端处于非事务状态下时，
所有发送给服务器端的命令都会立即被服务器执行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s2">&quot;hello moto&quot;</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">msg</span>
<span class="s2">&quot;hello moto&quot;</span>
</pre></div>
</div>
<p>但是，
当客户端进入事务状态之后，
服务器在收到来自客户端的命令时，
不会立即执行命令，
而是将这些命令全部放进一个事务队列里，
然后返回 <code class="docutils literal notranslate"><span class="pre">QUEUED</span></code> ，
表示命令已入队：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s2">&quot;hello moto&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">msg</span>
<span class="n">QUEUED</span>
</pre></div>
</div>
<p>以下流程图展示了这一行为：</p>
<div class="graphviz"><img src="../_images/graphviz-8dbab2bb36cd7db70b255be73898b6e18e22bf4e.png" alt="digraph enqueue {

    node [shape = plaintext, style = filled];

    edge [style = bold];

    command_in [label = &quot;服务器接到来自客户端的命令&quot;];

    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];

    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];

    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];

    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];

    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];

    // 

    command_in -&gt; in_transaction_or_not;

    in_transaction_or_not -&gt; enqueu_command [label = &quot;是&quot;];

    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];

    exec_command -&gt; return_command_result;

    enqueu_command -&gt; return_enqueued;
}" class="graphviz" /></div>
<p>事务队列是一个数组，
每个数组项是都包含三个属性：</p>
<ol class="arabic simple">
<li><p>要执行的命令（cmd）。</p></li>
<li><p>命令的参数（argv）。</p></li>
<li><p>参数的个数（argc）。</p></li>
</ol>
<p>举个例子，
如果客户端执行以下命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;Mastering C++ in 21 days&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">tag</span> <span class="s2">&quot;C++&quot;</span> <span class="s2">&quot;Programming&quot;</span> <span class="s2">&quot;Mastering Series&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">tag</span>
<span class="n">QUEUED</span>
</pre></div>
</div>
<p>那么程序将为客户端创建以下事务队列：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>数组索引</p></th>
<th class="head"><p>cmd</p></th>
<th class="head"><p>argv</p></th>
<th class="head"><p>argc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SET</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;book-name&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">GET</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;book-name&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SADD</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;tag&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">Series&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">4</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">3</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SMEMBERS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;tag&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="id5">
<h2>执行事务<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h2>
<p>前面说到，
当客户端进入事务状态之后，
客户端发送的命令就会被放进事务队列里。</p>
<p>但其实并不是所有的命令都会被放进事务队列，
其中的例外就是 <span class="xref std std-ref">EXEC</span> 、 <span class="xref std std-ref">DISCARD</span> 、 <span class="xref std std-ref">MULTI</span> 和 <span class="xref std std-ref">WATCH</span> 这四个命令 ——
当这四个命令从客户端发送到服务器时，
它们会像客户端处于非事务状态一样，
直接被服务器执行：</p>
<div class="graphviz"><img src="../_images/graphviz-64725ea1852fd894478abc2a2c81dc63870e5f9d.png" alt="digraph not_enque_command {

    node [shape = plaintext, style = filled];

    edge [style = bold];

    command_in [label = &quot;服务器接到来自客户端的命令&quot;];

    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];

    not_exec_and_discard [label = &quot;命令是否\nEXEC 、 DISCARD 、\nMULTI 或 WATCH ？&quot;, shape = diamond, fillcolor = &quot;#FFC1C1&quot;];

    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];

    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];

    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];

    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];

    // 

    command_in -&gt; in_transaction_or_not;

    in_transaction_or_not -&gt; not_exec_and_discard [label = &quot;是&quot;];

    not_exec_and_discard -&gt; enqueu_command [label = &quot;否&quot;];

    not_exec_and_discard -&gt; exec_command [label = &quot;是&quot;];

    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];

    exec_command -&gt; return_command_result;

    enqueu_command -&gt; return_enqueued;
}" class="graphviz" /></div>
<p>如果客户端正处于事务状态，
那么当 <span class="xref std std-ref">EXEC</span> 命令执行时，
服务器根据客户端所保存的事务队列，
以先进先出（FIFO）的方式执行事务队列中的命令：
最先入队的命令最先执行，
而最后入队的命令最后执行。</p>
<p>比如说，对于以下事务队列：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>数组索引</p></th>
<th class="head"><p>cmd</p></th>
<th class="head"><p>argv</p></th>
<th class="head"><p>argc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SET</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;book-name&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">GET</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;book-name&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SADD</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;tag&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">Series&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">4</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">3</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SMEMBERS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;tag&quot;]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
</tr>
</tbody>
</table>
<p>程序会首先执行 <span class="xref std std-ref">SET</span> 命令，
然后执行 <span class="xref std std-ref">GET</span> 命令，
再然后执行 <span class="xref std std-ref">SADD</span> 命令，
最后执行 <span class="xref std std-ref">SMEMBERS</span> 命令。</p>
<p>执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<p>比如说，对于上面给出的事务队列，程序将为队列中的命令创建如下回复队列：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>数组索引</p></th>
<th class="head"><p>回复类型</p></th>
<th class="head"><p>回复内容</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p>status code reply</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">OK</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p>bulk reply</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">2</span></code></p></td>
<td><p>integer reply</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">3</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">3</span></code></p></td>
<td><p>multi-bulk reply</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[&quot;Mastering</span> <span class="pre">Series&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;]</span></code></p></td>
</tr>
</tbody>
</table>
<p>当事务队列里的所有命令被执行完之后，
<span class="xref std std-ref">EXEC</span> 命令会将回复队列作为自己的执行结果返回给客户端，
客户端从事务状态返回到非事务状态，
至此，
事务执行完毕。</p>
<p>事务的整个执行过程可以用以下伪代码表示：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute_transaction</span><span class="p">():</span>

    <span class="c1"># 创建空白的回复队列</span>
    <span class="n">reply_queue</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 取出事务队列里的所有命令、参数和参数数量</span>
    <span class="k">for</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span> <span class="ow">in</span> <span class="n">client</span><span class="o">.</span><span class="n">transaction_queue</span><span class="p">:</span>

        <span class="c1"># 执行命令，并取得命令的返回值</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">execute_redis_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">)</span>

        <span class="c1"># 将返回值追加到回复队列末尾</span>
        <span class="n">reply_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reply</span><span class="p">)</span>

    <span class="c1"># 清除客户端的事务状态</span>
    <span class="n">clear_transaction_state</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

    <span class="c1"># 清空事务队列</span>
    <span class="n">clear_transaction_queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

    <span class="c1"># 将事务的执行结果返回给客户端</span>
    <span class="n">send_reply_to_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">reply_queue</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id6">
<h2>在事务和非事务状态下执行命令<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h2>
<p>无论在事务状态下，
还是在非事务状态下，
Redis 命令都由同一个函数执行，
所以它们共享很多服务器的一般设置，
比如 AOF 的配置、RDB 的配置，以及内存限制，等等。</p>
<p>不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：</p>
<ol class="arabic">
<li><p>非事务状态下的命令以单个命令为单位执行，前一个命令和后一个命令的客户端不一定是同一个；</p>
<p>而事务状态则是以一个事务为单位，执行事务队列中的所有命令：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</p>
</li>
<li><p>在非事务状态下，执行命令所得的结果会立即被返回给客户端；</p>
<p>而事务则是将所有命令的结果集合到回复队列，再作为 <span class="xref std std-ref">EXEC</span> 命令的结果返回给客户端。</p>
</li>
</ol>
</section>
<section id="discard-multi-watch">
<h2>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令<a class="headerlink" href="#discard-multi-watch" title="Link to this heading">¶</a></h2>
<p>除了 <span class="xref std std-ref">EXEC</span> 之外，
服务器在客户端处于事务状态时，
不加入到事务队列而直接执行的另外三个命令是 <span class="xref std std-ref">DISCARD</span> 、 <span class="xref std std-ref">MULTI</span> 和 <span class="xref std std-ref">WATCH</span> 。</p>
<p><span class="xref std std-ref">DISCARD</span> 命令用于取消一个事务，
它清空客户端的整个事务队列，
然后将客户端从事务状态调整回非事务状态，
最后返回字符串 <code class="docutils literal notranslate"><span class="pre">OK</span></code> 给客户端，
说明事务已被取消。</p>
<p>Redis 的事务是不可嵌套的，
当客户端已经处于事务状态，
而客户端又再向服务器发送 <span class="xref std std-ref">MULTI</span> 时，
服务器只是简单地向客户端发送一个错误，
然后继续等待其他命令的入队。
<span class="xref std std-ref">MULTI</span> 命令的发送不会造成整个事务失败，
也不会修改事务队列中已有的数据。</p>
<p><span class="xref std std-ref">WATCH</span> 只能在客户端进入事务状态之前执行，
在事务状态下发送 <span class="xref std std-ref">WATCH</span> 命令会引发一个错误，
但它不会造成整个事务失败，
也不会修改事务队列中已有的数据（和前面处理 <span class="xref std std-ref">MULTI</span> 的情况一样）。</p>
</section>
<section id="watch">
<h2>带 WATCH 的事务<a class="headerlink" href="#watch" title="Link to this heading">¶</a></h2>
<p><span class="xref std std-ref">WATCH</span> 命令用于在事务开始之前监视任意数量的键：
当调用 <span class="xref std std-ref">EXEC</span> 命令执行事务时，
如果任意一个被监视的键已经被其他客户端修改了，
那么整个事务不再执行，
直接返回失败。</p>
<p>以下示例展示了一个执行失败的事务例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">WATCH</span> <span class="n">name</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">name</span> <span class="n">peter</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>以下执行序列展示了上面的例子是如何失败的：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>时间</p></th>
<th class="head"><p>客户端 A</p></th>
<th class="head"><p>客户端 B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">WATCH</span> <span class="pre">name</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>T2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">MULTI</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>T3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">name</span> <span class="pre">peter</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>T4</p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">name</span> <span class="pre">john</span></code></p></td>
</tr>
<tr class="row-even"><td><p>T5</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EXEC</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>在时间 T4 ，客户端 B 修改了 <code class="docutils literal notranslate"><span class="pre">name</span></code> 键的值，
当客户端 A 在 T5 执行 <span class="xref std std-ref">EXEC</span> 时，Redis 会发现 <code class="docutils literal notranslate"><span class="pre">name</span></code> 这个被监视的键已经被修改，
因此客户端 A 的事务不会被执行，而是直接返回失败。</p>
<p>下文就来介绍 <span class="xref std std-ref">WATCH</span> 的实现机制，并且看看事务系统是如何检查某个被监视的键是否被修改，从而保证事务的安全性的。</p>
</section>
<section id="id7">
<h2>WATCH 命令的实现<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h2>
<p>在每个代表数据库的 <code class="docutils literal notranslate"><span class="pre">redis.h/redisDb</span></code> 结构类型中，
都保存了一个 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典，
字典的键是这个数据库被监视的键，
而字典的值则是一个链表，
链表中保存了所有监视这个键的客户端。</p>
<p>比如说，以下字典就展示了一个 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典的例子：</p>
<div class="graphviz"><img src="../_images/graphviz-0b04f2296fe3e75f14ae43cde7873e48f58b3f7b.png" alt="digraph watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}" class="graphviz" /></div>
<p>其中， 键 <code class="docutils literal notranslate"><span class="pre">key1</span></code> 正在被 <code class="docutils literal notranslate"><span class="pre">client2</span></code> 、 <code class="docutils literal notranslate"><span class="pre">client5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">client1</span></code> 三个客户端监视，
其他一些键也分别被其他别的客户端监视着。</p>
<p><span class="xref std std-ref">WATCH</span> 命令的作用，
就是将当前客户端和要监视的键在 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 中进行关联。</p>
<p>举个例子，
如果当前客户端为 <code class="docutils literal notranslate"><span class="pre">client10086</span></code> ，
那么当客户端执行 <code class="docutils literal notranslate"><span class="pre">WATCH</span> <span class="pre">key1</span> <span class="pre">key2</span></code> 时，
前面展示的 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 将被修改成这个样子：</p>
<div class="graphviz"><img src="../_images/graphviz-64fc562ce8711491a6327fe68ad340a6af6cceed.png" alt="digraph new_watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    client10086 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; client10086;
    client10086 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    client10086_2 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; client10086_2;
    client10086_2 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}" class="graphviz" /></div>
<p>通过 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典，
如果程序想检查某个键是否被监视，
那么它只要检查字典中是否存在这个键即可；
如果程序要获取监视某个键的所有客户端，
那么只要取出键的值（一个链表），
然后对链表进行遍历即可。</p>
</section>
<section id="id8">
<h2>WATCH 的触发<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h2>
<p>在任何对数据库键空间（key space）进行修改的命令成功执行之后
（比如 <span class="xref std std-ref">FLUSHDB</span> 、 <span class="xref std std-ref">SET</span> 、 <span class="xref std std-ref">DEL</span> 、 <span class="xref std std-ref">LPUSH</span> 、 <span class="xref std std-ref">SADD</span> 、 <span class="xref std std-ref">ZREM</span> ，诸如此类），
<code class="docutils literal notranslate"><span class="pre">multi.c/touchWatchedKey</span></code> 函数都会被调用 ——
它检查数据库的 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典，
看是否有客户端在监视已经被命令修改的键，
如果有的话，
程序将所有监视这个/这些被修改键的客户端的 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项打开：</p>
<div class="graphviz"><img src="../_images/graphviz-14bd8df5c181fc135958a749329fdc60126dbf82.png" alt="digraph dirty_cas {

    rankdir = LR;

    node [shape = circle, style = filled];

    edge [style = bold];

    label = &quot;客户端状态的切换&quot;;

    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];

    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];

    dirty_cas [label = &quot;事务安全性\n已被破坏&quot;, fillcolor = &quot;#B22222&quot;];

    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];

    transaction -&gt; dirty_cas [label = &quot;打开选项\nREDIS_DIRTY_CAS&quot;];
}" class="graphviz" /></div>
<p>当客户端发送 <span class="xref std std-ref">EXEC</span> 命令、触发事务执行时，
服务器会对客户端的状态进行检查：</p>
<ul class="simple">
<li><p>如果客户端的 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</p></li>
</ul>
<p>可以用一段伪代码来表示这个检查：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">check_safety_before_execute_trasaction</span><span class="p">():</span>

    <span class="k">if</span> <span class="n">client</span><span class="o">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">REDIS_DIRTY_CAS</span><span class="p">:</span>
        <span class="c1"># 安全性已破坏，清除事务状态</span>
        <span class="n">clear_transaction_state</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="c1"># 清空事务队列</span>
        <span class="n">clear_transaction_queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="c1"># 返回空回复给客户端</span>
        <span class="n">send_empty_reply</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 安全性完好，执行事务</span>
        <span class="n">execute_transaction</span><span class="p">()</span>
</pre></div>
</div>
<p>举个例子，假设数据库的 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典如下图所示：</p>
<div class="graphviz"><img src="../_images/graphviz-0b04f2296fe3e75f14ae43cde7873e48f58b3f7b.png" alt="digraph watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}" class="graphviz" /></div>
<p>如果某个客户端对 <code class="docutils literal notranslate"><span class="pre">key1</span></code> 进行了修改（比如执行 <code class="docutils literal notranslate"><span class="pre">DEL</span> <span class="pre">key1</span></code> ），
那么所有监视 <code class="docutils literal notranslate"><span class="pre">key1</span></code> 的客户端，
包括 <code class="docutils literal notranslate"><span class="pre">client2</span></code> 、 <code class="docutils literal notranslate"><span class="pre">client5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">client1</span></code> 的 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项都会被打开，
当客户端 <code class="docutils literal notranslate"><span class="pre">client2</span></code> 、 <code class="docutils literal notranslate"><span class="pre">client5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">client1</span></code> 执行 <span class="xref std std-ref">EXEC</span> 的时候，
它们的事务都会以失败告终。</p>
<p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典中和这个客户端相关的资料都会被清除。</p>
</section>
<section id="acid">
<h2>事务的 ACID 性质<a class="headerlink" href="#acid" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>勘误：Redis 的事务是保证原子性的，本节的内容将原子性和回滚功能混淆了，等待修复中。 —— 2013.6.23</p>
</div>
<p>在传统的关系式数据库中，常常用 <a class="reference external" href="http://en.wikipedia.org/wiki/ACID">ACID 性质</a>来检验事务功能的安全性。</p>
<p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<p>以下四小节是关于这四个性质的详细讨论。</p>
<section id="atomicity">
<h3>原子性（Atomicity）<a class="headerlink" href="#atomicity" title="Link to this heading">¶</a></h3>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>
<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>
<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>
</section>
<section id="consistency">
<h3>一致性（Consistency）<a class="headerlink" href="#consistency" title="Link to this heading">¶</a></h3>
<p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<section id="id10">
<h4>入队错误<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h4>
<p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等，
那么服务器将向客户端返回一个出错信息，
并且将客户端的事务状态设为 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_EXEC</span></code> 。</p>
<p>当客户端执行 <span class="xref std std-ref">EXEC</span> 命令时，
Redis 会拒绝执行状态为 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_EXEC</span></code> 的事务，
并返回失败信息。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span> <span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span> <span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span> <span class="nb">set</span> <span class="n">key</span>
<span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="n">ERR</span> <span class="n">wrong</span> <span class="n">number</span> <span class="n">of</span> <span class="n">arguments</span> <span class="k">for</span> <span class="s1">&#39;set&#39;</span> <span class="n">command</span>

<span class="n">redis</span> <span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span> <span class="n">EXISTS</span> <span class="n">key</span>
<span class="n">QUEUED</span>

<span class="n">redis</span> <span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="n">EXECABORT</span> <span class="n">Transaction</span> <span class="n">discarded</span> <span class="n">because</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">errors</span><span class="o">.</span>
</pre></div>
</div>
<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>
</section>
<section id="id11">
<h4>执行错误<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h4>
<p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作，
那么 Redis 只会将错误包含在事务的结果中，
这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令，
所以它对事务的一致性也没有影响。</p>
</section>
<section id="redis">
<h4>Redis 进程被终结<a class="headerlink" href="#redis" title="Link to this heading">¶</a></h4>
<p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>
<ul>
<li><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p></li>
<li><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p></li>
<li><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>
<p>1）如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>
<p>2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>
</li>
</ul>
</section>
</section>
<section id="isolation">
<h3>隔离性（Isolation）<a class="headerlink" href="#isolation" title="Link to this heading">¶</a></h3>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
</section>
<section id="durability">
<h3>持久性（Durability）<a class="headerlink" href="#durability" title="Link to this heading">¶</a></h3>
<p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>
<ul>
<li><p>在单纯的内存模式下，事务肯定是不持久的。</p></li>
<li><p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p></li>
<li><p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code class="docutils literal notranslate"><span class="pre">fsync</span></code> 或 <code class="docutils literal notranslate"><span class="pre">fdatasync</span></code> 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>
<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>
</li>
</ul>
</section>
</section>
<section id="id12">
<h2>小结<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</p></li>
<li><p>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</p></li>
<li><p>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</p></li>
<li><p>带 <code class="docutils literal notranslate"><span class="pre">WATCH</span></code> 命令的事务会将客户端和被监视的键在数据库的 <code class="docutils literal notranslate"><span class="pre">watched_keys</span></code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项打开。</p></li>
<li><p>只有在客户端的 <code class="docutils literal notranslate"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项未被打开时，才能执行事务，否则事务直接返回失败。</p></li>
<li><p>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="sphinx-toc sphinxlocaltoc">
    <h3><a href="../index.html">Page contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">事务</a><ul>
<li><a class="reference internal" href="#id2">事务</a></li>
<li><a class="reference internal" href="#id3">开始事务</a></li>
<li><a class="reference internal" href="#id4">命令入队</a></li>
<li><a class="reference internal" href="#id5">执行事务</a></li>
<li><a class="reference internal" href="#id6">在事务和非事务状态下执行命令</a></li>
<li><a class="reference internal" href="#discard-multi-watch">事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</a></li>
<li><a class="reference internal" href="#watch">带 WATCH 的事务</a></li>
<li><a class="reference internal" href="#id7">WATCH 命令的实现</a></li>
<li><a class="reference internal" href="#id8">WATCH 的触发</a></li>
<li><a class="reference internal" href="#acid">事务的 ACID 性质</a><ul>
<li><a class="reference internal" href="#atomicity">原子性（Atomicity）</a></li>
<li><a class="reference internal" href="#consistency">一致性（Consistency）</a><ul>
<li><a class="reference internal" href="#id10">入队错误</a></li>
<li><a class="reference internal" href="#id11">执行错误</a></li>
<li><a class="reference internal" href="#redis">Redis 进程被终结</a></li>
</ul>
</li>
<li><a class="reference internal" href="#isolation">隔离性（Isolation）</a></li>
<li><a class="reference internal" href="#durability">持久性（Durability）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">小结</a></li>
</ul>
</li>
</ul>

  </div>
  <div class="sphinxprev">
    <h4>Previous page</h4>
    <p class="topless"><a href="../datatype/sorted_set.html"
                          title="Previous page">&larr; 有序集</a></p>
  </div>
  <div class="sphinxnext">
    <h4>Next page</h4>
    <p class="topless"><a href="pubsub.html"
                          title="Next page">&rarr; 订阅与发布</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/feature/transaction.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="pubsub.html" title="订阅与发布"
             >下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../datatype/sorted_set.html" title="有序集"
             >上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">RedisBookOrigin 1.0 文档</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">事务</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
    &#169; 版权所有 2024, 黄健宏.
      由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6创建。
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>