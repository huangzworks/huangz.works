

<!DOCTYPE html>

<html lang="zh-cn" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>数据库 &#8212; RedisBookOrigin 1.0 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/cloud.css?v=f9ae72be" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" href="../" type="text/css" />
    
    <script src="../_static/documentation_options.js?v=27ad66bf"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    
    
     
        <script src="../_static/cloud.base.js"></script>
    

    
     
        <script src="../_static/cloud.js"></script>
    

    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="RDB" href="rdb.html" />
    <link rel="prev" title="慢查询日志" href="../feature/slowlog.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="rdb.html" title="RDB"
             accesskey="N">下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../feature/slowlog.html" title="慢查询日志"
             accesskey="P">上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">RedisBookOrigin 1.0 文档</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">数据库</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="db-chapter">
<span id="id1"></span><h1>数据库<a class="headerlink" href="#db-chapter" title="Link to this heading">¶</a></h1>
<p>本章将对 Redis 数据库的构造和实现进行讨论。</p>
<p>除了说明数据库是如何储存数据对象之外，本章还会讨论键的过期信息是如何保存，而 Redis 又是如何删除过期键的。</p>
<section id="id2">
<h2>数据库的结构<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p>Redis 中的每个数据库，都由一个 <code class="docutils literal notranslate"><span class="pre">redis.h/redisDb</span></code> 结构表示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>typedef struct redisDb {

    // 保存着数据库以整数表示的号码
    int id;

    // 保存着数据库中的所有键值对数据
    // 这个属性也被称为键空间（key space）
    dict *dict;

    // 保存着键的过期信息
    dict *expires;

    // 实现列表阻塞原语，如 BLPOP
    // 在列表类型一章有详细的讨论
    dict *blocking_keys;
    dict *ready_keys;

    // 用于实现 WATCH 命令
    // 在事务章节有详细的讨论
    dict *watched_keys;

} redisDb;
</pre></div>
</div>
<p>下文将详细讨论  <code class="docutils literal notranslate"><span class="pre">id</span></code> 、 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 和 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 三个属性，
以及针对这三个属性所执行的数据库操作。</p>
</section>
<section id="id3">
<h2>数据库的切换<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">redisDb</span></code> 结构的 <code class="docutils literal notranslate"><span class="pre">id</span></code> 域保存着数据库的号码。</p>
<p>这个号码很容易让人将它和切换数据库的 <span class="xref std std-ref">SELECT</span> 命令联系在一起，
但是，
实际上，
<code class="docutils literal notranslate"><span class="pre">id</span></code> 属性并不是用来实现 <span class="xref std std-ref">SELECT</span> 命令，
而是给 Redis 内部程序使用的。</p>
<p>当 Redis 服务器初始化时，
它会创建出 <code class="docutils literal notranslate"><span class="pre">redis.h/REDIS_DEFAULT_DBNUM</span></code> 个数据库，
并将所有数据库保存到 <code class="docutils literal notranslate"><span class="pre">redis.h/redisServer.db</span></code> 数组中，
每个数据库的 <code class="docutils literal notranslate"><span class="pre">id</span></code> 为从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">REDIS_DEFAULT_DBNUM</span> <span class="pre">-</span> <span class="pre">1</span></code> 的值。</p>
<p>当执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">number</span></code> 命令时，程序直接使用 <code class="docutils literal notranslate"><span class="pre">redisServer.db[number]</span></code> 来切换数据库。</p>
<p>但是，
一些内部程序，
比如 AOF 程序、复制程序和 RDB 程序，
需要知道当前数据库的号码，
如果没有 <code class="docutils literal notranslate"><span class="pre">id</span></code> 域的话，
程序就只能在当前使用的数据库的指针，
和 <code class="docutils literal notranslate"><span class="pre">redisServer.db</span></code> 数组中所有数据库的指针进行对比，
以此来弄清楚自己正在使用的是那个数据库。</p>
<p>以下伪代码描述了这个对比过程：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">PSEUDO_GET_CURRENT_DB_NUMBER</span><span class="p">(</span><span class="n">current_db_pointer</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">db_pointer</span> <span class="ow">in</span> <span class="n">redisServer</span><span class="o">.</span><span class="n">db</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">db_pointer</span> <span class="o">==</span> <span class="n">current_db_pointer</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
<p>有了 <code class="docutils literal notranslate"><span class="pre">id</span></code> 域的话，
程序就可以通过读取 <code class="docutils literal notranslate"><span class="pre">id</span></code> 域来了解自己正在使用的是哪个数据库，
这样就不用对比指针那么麻烦了。</p>
</section>
<section id="id4">
<h2>数据库键空间<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p>因为 Redis 是一个键值对数据库（key-value pairs database），
所以它的数据库本身也是一个字典（俗称 key space）：</p>
<ul class="simple">
<li><p>字典的键是一个<a class="reference internal" href="../datatype/string.html#string-chapter"><span class="std std-ref">字符串</span></a>对象。</p></li>
<li><p>字典的值则可以是包括<a class="reference internal" href="../datatype/string.html#string-chapter"><span class="std std-ref">字符串</span></a>、<a class="reference internal" href="../datatype/list.html#list-chapter"><span class="std std-ref">列表</span></a>、<a class="reference internal" href="../datatype/hash.html#hash-chapter"><span class="std std-ref">哈希表</span></a>、<a class="reference internal" href="../datatype/set.html#set-chapter"><span class="std std-ref">集合</span></a>或<a class="reference internal" href="../datatype/sorted_set.html#sorted-set-chapter"><span class="std std-ref">有序集</span></a>在内的任意一种 Redis 类型对象。</p></li>
</ul>
<p>在 <code class="docutils literal notranslate"><span class="pre">redisDb</span></code> 结构的 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 属性中，保存着数据库的所有键值对数据。</p>
<p>下图展示了一个包含 <code class="docutils literal notranslate"><span class="pre">number</span></code> 、 <code class="docutils literal notranslate"><span class="pre">book</span></code> 、 <code class="docutils literal notranslate"><span class="pre">message</span></code> 三个键的数据库 ——
其中 <code class="docutils literal notranslate"><span class="pre">number</span></code> 键是一个列表，列表中包含三个整数值；
<code class="docutils literal notranslate"><span class="pre">book</span></code> 键是一个哈希表，表中包含三个键值对；
而 <code class="docutils literal notranslate"><span class="pre">message</span></code> 键则指向另一个字符串：</p>
<div class="graphviz"><img src="../_images/graphviz-292cada2d541b2a528e38365d5d0713caaea6efa.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
</section>
<section id="id5">
<h2>键空间的操作<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h2>
<p>因为数据库本身是一个字典，
所以对数据库的操作基本上都是对字典的操作，
加上以下一些维护操作：</p>
<ul class="simple">
<li><p>更新键的命中率和不命中率，这个值可以用 <span class="xref std std-ref">INFO</span> 命令查看；</p></li>
<li><p>更新键的 LRU 时间，这个值可以用 <span class="xref std std-ref">OBJECT</span> 命令来查看；</p></li>
<li><p>删除过期键（稍后会详细说明）；</p></li>
<li><p>如果键被修改了的话，那么将键设为脏（用于事务监视），并将服务器设为脏（等待 RDB 保存）；</p></li>
<li><p>将对键的修改发送到 AOF 文件和附属节点，保持数据库状态的一致；</p></li>
</ul>
<p>作为例子，以下几个小节会展示键的添加、删除、更新、取值等几个主要操作。</p>
<section id="id6">
<h3>添加新键<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>添加一个新键对到数据库，
实际上就是将一个新的键值对添加到键空间字典中，
其中键为字符串对象，
而值则是任意一种 Redis 类型值对象。</p>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<div class="graphviz"><img src="../_images/graphviz-292cada2d541b2a528e38365d5d0713caaea6efa.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
<p>那么在客户端执行 <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">date</span> <span class="pre">2013.2.1</span></code> 命令之后，数据库更新为下图状态：</p>
<div class="graphviz"><img src="../_images/graphviz-1457e8acfc84365a7a2effed197af402ea8ce2fd.png" alt="digraph db_after_insert_new_key {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; |&lt;date&gt;StringObject\n \&quot;date\&quot; |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    date [label =  &quot;&lt;head&gt;StringObject | \&quot;2013.2.1\&quot;&quot;, fillcolor = &quot;#FFC1C1&quot;];
    
    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:date -&gt; date;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
</section>
<section id="id7">
<h3>删除键<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<p>删除数据库中的一个键，
实际上就是删除字典空间中对应的键对象和值对象。</p>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<div class="graphviz"><img src="../_images/graphviz-292cada2d541b2a528e38365d5d0713caaea6efa.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
<p>那么在客户端执行 <code class="docutils literal notranslate"><span class="pre">DEL</span> <span class="pre">message</span></code> 命令之后，数据库更新为下图状态：</p>
<div class="graphviz"><img src="../_images/graphviz-8646bb8e49f95cf3599cafbba8e2bde02bb3a1d6.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; | NULL&quot;, fillcolor = &quot;#FFC1C1&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
</section>
<section id="id8">
<h3>更新键<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h3>
<p>当对一个已存在于数据库的键执行更新操作时，
数据库释放键原来的值对象，
然后将指针指向新的值对象。</p>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<div class="graphviz"><img src="../_images/graphviz-292cada2d541b2a528e38365d5d0713caaea6efa.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
<p>那么在客户端执行 <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">message</span> <span class="pre">&quot;blah</span> <span class="pre">blah&quot;</span></code> 命令之后，数据库更新为下图状态：</p>
<div class="graphviz"><img src="../_images/graphviz-bc7297979fb5533f2d26d008979f3ac9f50ab3da.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;blah blah\&quot;&quot;, fillcolor = &quot;#FFC1C1&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
</section>
<section id="id9">
<h3>取值<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h3>
<p>在数据库中取值实际上就是在字典空间中取值，
再加上一些额外的类型检查：</p>
<ul class="simple">
<li><p>键不存在，返回空回复；</p></li>
<li><p>键存在，且类型正确，按照通讯协议返回值对象；</p></li>
<li><p>键存在，但类型不正确，返回类型错误。</p></li>
</ul>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<div class="graphviz"><img src="../_images/graphviz-292cada2d541b2a528e38365d5d0713caaea6efa.png" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" class="graphviz" /></div>
<p>当客户端执行 <code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">message</span></code> 时，服务器返回 <code class="docutils literal notranslate"><span class="pre">&quot;hello</span> <span class="pre">moto&quot;</span></code> 。</p>
<p>当客户端执行 <code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">not-exists-key</span></code> 时，服务器返回空回复。</p>
<p>当服务器执行 <code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">book</span></code> 时，服务器返回类型错误。</p>
</section>
<section id="id10">
<h3>其他操作<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p>除了上面展示的键值操作之外，还有很多针对数据库本身的命令，也是通过对键空间进行处理来完成的：</p>
<ul class="simple">
<li><p><span class="xref std std-ref">FLUSHDB</span> 命令：删除键空间中的所有键值对。</p></li>
<li><p><span class="xref std std-ref">RANDOMKEY</span> 命令：从键空间中随机返回一个键。</p></li>
<li><p><span class="xref std std-ref">DBSIZE</span> 命令：返回键空间中键值对的数量。</p></li>
<li><p><span class="xref std std-ref">EXISTS</span> 命令：检查给定键是否存在于键空间中。</p></li>
<li><p><span class="xref std std-ref">RENAME</span> 命令：在键空间中，对给定键进行改名。</p></li>
</ul>
<p>等等。</p>
</section>
</section>
<section id="id11">
<h2>键的过期时间<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h2>
<p>在前面的内容中，
我们讨论了很多涉及数据库本身、以及对数据库中的键值对进行处理的操作，
但是，
关于数据库如何保存键的过期时间，
以及如何处理过期键这一问题，
我们还没有讨论到。</p>
<p>通过 <span class="xref std std-ref">EXPIRE</span> 、 <span class="xref std std-ref">PEXPIRE</span> 、 <span class="xref std std-ref">EXPIREAT</span> 和 <span class="xref std std-ref">PEXPIREAT</span> 四个命令，
客户端可以给某个存在的键设置过期时间，
当键的过期时间到达时，
键就不再可用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SETEX</span> <span class="n">key</span> <span class="mi">5</span> <span class="n">value</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">key</span>
<span class="s2">&quot;value&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">key</span>   <span class="o">//</span> <span class="mi">5</span> <span class="n">秒过后</span>
<span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>命令 <span class="xref std std-ref">TTL</span> 和 <span class="xref std std-ref">PTTL</span> 则用于返回给定键距离过期还有多长时间：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SETEX</span> <span class="n">key</span> <span class="mi">10086</span> <span class="n">value</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">TTL</span> <span class="n">key</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">10082</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">PTTL</span> <span class="n">key</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">10068998</span>
</pre></div>
</div>
<p>在接下来的内容中，
我们将探讨和键的过期时间相关的问题：
比如键的过期时间是如何保存的，
而过期键又是如何被删除的，
等等。</p>
</section>
<section id="id12">
<h2>过期时间的保存<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h2>
<p>在数据库中，
所有键的过期时间都被保存在 <code class="docutils literal notranslate"><span class="pre">redisDb</span></code> 结构的 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典里：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">redisDb</span> <span class="p">{</span>

    <span class="o">//</span> <span class="o">...</span>

    <span class="nb">dict</span> <span class="o">*</span><span class="n">expires</span><span class="p">;</span>

    <span class="o">//</span> <span class="o">...</span>

<span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典的键是一个指向 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 字典（键空间）里某个键的指针，
而字典的值则是键所指向的数据库键的到期时间，
这个值以 <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> 类型表示。</p>
<p>下图展示了一个含有三个键的数据库，其中 <code class="docutils literal notranslate"><span class="pre">number</span></code> 和 <code class="docutils literal notranslate"><span class="pre">book</span></code> 两个键带有过期时间：</p>
<div class="graphviz"><img src="../_images/graphviz-89982b106f563455891b38a0abe79246331f4918.png" alt="digraph db_with_expire_time {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict |&lt;expires&gt; expires | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    // dict

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // dict edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;

    // expires

    expires [label = &quot;&lt;head&gt;dict |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; | NULL &quot;, fillcolor = &quot;#95BBE3&quot;];

    expire_of_number [label = &quot;&lt;head&gt;long long | 1360454400000 &quot;];

    expire_of_book [label = &quot;&lt;head&gt;long long | 1360800000000 &quot;];

    // expires edge

    redisDb:expires -&gt; expires:head;

    expires:number -&gt; expire_of_number:head;
    expires:book -&gt; expire_of_book:head;

}" class="graphviz" /></div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为了展示的方便，
图中重复出现了两次 <code class="docutils literal notranslate"><span class="pre">number</span></code> 键和 <code class="docutils literal notranslate"><span class="pre">book</span></code> 键。
在实际中，
键空间字典的键和过期时间字典的键都指向同一个字符串对象，
所以不会浪费任何空间。</p>
</div>
</section>
<section id="id13">
<h2>设置生存时间<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h2>
<p>Redis 有四个命令可以设置键的生存时间（可以存活多久）和过期时间（什么时候到期）：</p>
<ul class="simple">
<li><p><span class="xref std std-ref">EXPIRE</span> 以秒为单位设置键的生存时间；</p></li>
<li><p><span class="xref std std-ref">PEXPIRE</span> 以毫秒为单位设置键的生存时间；</p></li>
<li><p><span class="xref std std-ref">EXPIREAT</span> 以秒为单位，设置键的过期 UNIX 时间戳；</p></li>
<li><p><span class="xref std std-ref">PEXPIREAT</span> 以毫秒为单位，设置键的过期 UNIX 时间戳。</p></li>
</ul>
<p>虽然有那么多种不同单位和不同形式的设置方式，
但是 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典的值只保存“以毫秒为单位的过期 UNIX 时间戳”，
这就是说，
通过进行转换，
所有命令的效果最后都和 <span class="xref std std-ref">PEXPIREAT</span> 命令的效果一样。</p>
<p>举个例子，从 <span class="xref std std-ref">EXPIRE</span> 命令到 <span class="xref std std-ref">PEXPIREAT</span> 命令的转换可以用伪代码表示如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">EXPIRE</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">sec</span><span class="p">):</span>

    <span class="c1"># 将 TTL 从秒转换为毫秒</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">sec_to_ms</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span>

    <span class="c1"># 获取以毫秒计算的当前 UNIX 时间戳</span>
    <span class="n">ts_in_ms</span> <span class="o">=</span> <span class="n">get_current_unix_timestamp_in_ms</span><span class="p">()</span>

    <span class="c1"># 毫秒 TTL 加上毫秒时间戳，就是 key 到期的时间戳</span>
    <span class="n">PEXPIREAT</span><span class="p">(</span><span class="n">ms</span> <span class="o">+</span> <span class="n">ts_in_ms</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>其他函数的转换方式也是类似的。</p>
<p>作为例子，
下图展示了一个 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典示例，
字典中 <code class="docutils literal notranslate"><span class="pre">number</span></code> 键的过期时间是 2013 年 2 月 10 日（农历新年），
而 <code class="docutils literal notranslate"><span class="pre">book</span></code> 键的过期时间则是 2013 年 2 月 14 日（情人节）：</p>
<div class="graphviz"><img src="../_images/graphviz-1c0c0c82aa644c5566f6438af44e83ad4bfd87e5.png" alt="digraph expires {

    rankdir = LR;

    node [shape = record, style =filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id | ... |&lt;expires&gt; expires | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    // expires

    expires [label = &quot;&lt;head&gt;dict |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; | NULL &quot;, fillcolor = &quot;#95BBE3&quot;];

    expire_of_number [label = &quot;&lt;head&gt;long long | 1360454400000 &quot;];

    expire_of_book [label = &quot;&lt;head&gt;long long | 1360800000000 &quot;];

    // expires edge

    redisDb:expires -&gt; expires:head;

    expires:number -&gt; expire_of_number:head;
    expires:book -&gt; expire_of_book:head;

}" class="graphviz" /></div>
<p>这两个键的过期时间可能是用以上四个命令的任意一个设置的，
但它们都以统一的格式被保存在 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典中。</p>
</section>
<section id="id14">
<h2>过期键的判定<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h2>
<p>通过 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典，
可以用以下步骤检查某个键是否过期：</p>
<ol class="arabic simple">
<li><p>检查键是否存在于 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典：如果存在，那么取出键的过期时间；</p></li>
<li><p>检查当前 UNIX 时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则，键未过期。</p></li>
</ol>
<p>可以用伪代码来描述这一过程：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_expired</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>

    <span class="c1"># 取出键的过期时间</span>
    <span class="n">key_expire_time</span> <span class="o">=</span> <span class="n">expires</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1"># 如果过期时间不为空，并且当前时间戳大于过期时间，那么键已经过期</span>
    <span class="k">if</span> <span class="n">expire_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">current_timestamp</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">key_expire_time</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># 否则，键未过期或没有设置过期时间</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</section>
<section id="id15">
<h2>过期键的清除<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h2>
<p>我们知道了过期时间保存在 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典里，
又知道了该如何判定一个键是否过期，
现在剩下的问题是，
如果一个键是过期的，
那它什么时候会被删除？</p>
<p>这个问题有三种可能的答案：</p>
<ol class="arabic simple">
<li><p>定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。</p></li>
<li><p>惰性删除：放任键过期不管，但是在每次从 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 字典中取出键值时，要检查键是否过期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值。</p></li>
<li><p>定期删除：每隔一段时间，对 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典进行检查，删除里面的过期键。</p></li>
</ol>
<section id="id16">
<h3>定时删除<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h3>
<p>定时删除策略对内存是最友好的：
因为它保证过期键会在第一时间被删除，
过期键所消耗的内存会立即被释放。</p>
<p>这种策略的缺点是，
它对 CPU 时间是最不友好的：
因为删除操作可能会占用大量的 CPU 时间 ——
在内存不紧张、但是 CPU 时间非常紧张的时候
（比如说，进行交集计算或排序的时候），
将 CPU 时间花在删除那些和当前任务无关的过期键上，
这种做法毫无疑问会是低效的。</p>
<p>除此之外，
目前 Redis 事件处理器对时间事件的实现方式 —— 无序链表，
查找一个时间复杂度为 <span class="math notranslate nohighlight">\(O(N)\)</span>  —— 并不适合用来处理大量时间事件。</p>
</section>
<section id="id17">
<h3>惰性删除<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h3>
<p>惰性删除对 CPU 时间来说是最友好的：
它只会在取出键时进行检查，
这可以保证删除操作只会在非做不可的情况下进行 ——
并且删除的目标仅限于当前处理的键，
这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。</p>
<p>惰性删除的缺点是，
它对内存是最不友好的：
如果一个键已经过期，
而这个键又仍然保留在数据库中，
那么 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 字典和 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典都需要继续保存这个键的信息，
只要这个过期键不被删除，
它占用的内存就不会被释放。</p>
<p>在使用惰性删除策略时，
如果数据库中有非常多的过期键，
但这些过期键又正好没有被访问的话，
那么它们就永远也不会被删除（除非用户手动执行），
这对于性能非常依赖于内存大小的 Redis 来说，
肯定不是一个好消息。</p>
<p>举个例子，
对于一些按时间点来更新的数据，
比如日志（log），
在某个时间点之后，
对它们的访问就会大大减少，
如果大量的这些过期数据积压在数据库里面，
用户以为它们已经过期了（已经被删除了），
但实际上这些键却没有真正的被删除（内存也没有被释放），
那结果肯定是非常糟糕。</p>
</section>
<section id="id18">
<h3>定期删除<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h3>
<p>从上面对定时删除和惰性删除的讨论来看，
这两种删除方式在单一使用时都有明显的缺陷：
定时删除占用太多 CPU 时间，
惰性删除浪费太多内存。</p>
<p>定期删除是这两种策略的一种折中：</p>
<ul class="simple">
<li><p>它每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，籍此来减少删除操作对 CPU 时间的影响。</p></li>
<li><p>另一方面，通过定期删除过期键，它有效地减少了因惰性删除而带来的内存浪费。</p></li>
</ul>
</section>
<section id="redis">
<h3>Redis 使用的策略<a class="headerlink" href="#redis" title="Link to this heading">¶</a></h3>
<p>Redis 使用的过期键删除策略是惰性删除加上定期删除，
这两个策略相互配合，可以很好地在合理利用 CPU 时间和节约内存空间之间取得平衡。</p>
<p>因为前面已经说了这两个策略的概念了，下面两节就来探讨这两个策略在 Redis 中的具体实现。</p>
</section>
</section>
<section id="id19">
<h2>过期键的惰性删除策略<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h2>
<p>实现过期键惰性删除策略的核心是 <code class="docutils literal notranslate"><span class="pre">db.c/expireIfNeeded</span></code> 函数 ——
所有命令在读取或写入数据库之前，程序都会调用 <code class="docutils literal notranslate"><span class="pre">expireIfNeeded</span></code> 对输入键进行检查，
并将过期键删除：</p>
<div class="graphviz"><img src="../_images/graphviz-3a69caf5e845c091420f6c704719eb8d7a3ee67f.png" alt="digraph expire_check {
    
    node [style = filled, shape = plaintext];

    edge [style = bold];

    // node

    write_commands [label = &quot;SET 、\n LPUSH 、\n SADD 、 \n 等等&quot;, fillcolor = &quot;#FADCAD&quot;];

    read_commands [label = &quot;GET 、\n LRANGE 、\n SMEMBERS 、 \n 等等&quot;, fillcolor = &quot;#FADCAD&quot;];

    expire_if_needed [label = &quot;调用 expire_if_needed() \n 删除过期键&quot;, shape = box, fillcolor = &quot;#A8E270&quot;];

    process [label = &quot;执行实际的命令流程&quot;];

    // edge

    write_commands -&gt; expire_if_needed [label = &quot;写请求&quot;];

    read_commands -&gt; expire_if_needed [label = &quot;读请求&quot;];

    expire_if_needed -&gt; process;

}" class="graphviz" /></div>
<p>比如说， <code class="docutils literal notranslate"><span class="pre">GET</span></code> 命令的执行流程可以用下图来表示：</p>
<div class="graphviz"><img src="../_images/graphviz-72de8a50b9a469926723f2207b66df1ee04c1247.png" alt="digraph get_with_expire {

    node [style = filled, shape = plaintext];

    edge [style = bold];

    // node
  
    get [label = &quot;GET key&quot;, fillcolor = &quot;#FADCAD&quot;];

    expire_if_needed [label = &quot;调用\n expire_if_needed() \n 如果键已经过期 \n 那么将它删除&quot;, shape = diamond, fillcolor = &quot;#A8E270&quot;];

    expired_and_deleted [label = &quot;key 不存在\n 向客户端返回 NIL&quot;];

    not_expired [label = &quot;向客户端返回 key 的值&quot;];

    get -&gt; expire_if_needed;

    expire_if_needed -&gt; expired_and_deleted [label = &quot;已过期&quot;];
    expire_if_needed -&gt; not_expired [label = &quot;未过期&quot;];

}" class="graphviz" /></div>
<p><code class="docutils literal notranslate"><span class="pre">expireIfNeeded</span></code> 的作用是，
如果输入键已经过期的话，
那么将键、键的值、键保存在 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典中的过期时间都删除掉。</p>
<p>用伪代码描述的 <code class="docutils literal notranslate"><span class="pre">expireIfNeeded</span></code> 定义如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">expireIfNeeded</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>

    <span class="c1"># 对过期键执行以下操作 。。。</span>
    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">is_expired</span><span class="p">():</span>

        <span class="c1"># 从键空间中删除键值对</span>
        <span class="n">db</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># 删除键的过期时间</span>
        <span class="n">db</span><span class="o">.</span><span class="n">expires</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># 将删除命令传播到 AOF 文件和附属节点</span>
        <span class="n">propagateDelKeyToAofAndReplication</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id20">
<h2>过期键的定期删除策略<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h2>
<p>对过期键的定期删除由 <code class="docutils literal notranslate"><span class="pre">redis.c/activeExpireCycle</span></code> 函执行：
每当 Redis 的例行处理程序 <code class="docutils literal notranslate"><span class="pre">serverCron</span></code> 执行时，
<code class="docutils literal notranslate"><span class="pre">activeExpireCycle</span></code> 都会被调用 ——
这个函数在规定的时间限制内，
尽可能地遍历各个数据库的 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典，
随机地检查一部分键的过期时间，
并删除其中的过期键。</p>
<p>整个过程可以用伪代码描述如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">activeExpireCycle</span><span class="p">():</span>

    <span class="c1"># 遍历数据库（不一定能全部都遍历完，看时间是否足够）</span>
    <span class="k">for</span> <span class="n">db</span> <span class="ow">in</span> <span class="n">server</span><span class="o">.</span><span class="n">db</span><span class="p">:</span>

        <span class="c1"># MAX_KEY_PER_DB 是一个 DB 最大能处理的 key 个数</span>
        <span class="c1"># 它保证时间不会全部用在个别的 DB 上（避免饥饿）</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_KEY_PER_DB</span><span class="p">):</span>

            <span class="c1"># 数据库为空，跳出 while ，处理下个 DB</span>
            <span class="k">if</span> <span class="n">db</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span> <span class="k">break</span>

            <span class="c1"># 随机取出一个带 TTL 的键</span>
            <span class="n">key_with_ttl</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">expires</span><span class="o">.</span><span class="n">get_random_key</span><span class="p">()</span>

            <span class="c1"># 检查键是否过期，如果是的话，将它删除</span>
            <span class="k">if</span> <span class="n">is_expired</span><span class="p">(</span><span class="n">key_with_ttl</span><span class="p">):</span>
                <span class="n">db</span><span class="o">.</span><span class="n">deleteExpiredKey</span><span class="p">(</span><span class="n">key_with_ttl</span><span class="p">)</span>

            <span class="c1"># 当执行时间到达上限，函数就返回，不再继续</span>
            <span class="c1"># 这确保删除操作不会占用太多的 CPU 时间</span>
            <span class="k">if</span> <span class="n">reach_time_limit</span><span class="p">():</span> <span class="k">return</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="aof-rdb">
<h2>过期键对 AOF 、RDB 和复制的影响<a class="headerlink" href="#aof-rdb" title="Link to this heading">¶</a></h2>
<p>前面的内容讨论了过期键对 CPU 时间和内存的影响，现在，是时候说说过期键在 RDB 文件、 AOF 文件、 AOF 重写以及复制中的影响了：</p>
<p>过期键会被保存在更新后的 RDB 文件、 AOF 文件或者重写后的 AOF 文件里面吗？</p>
<p>附属节点会会如何处理过期键？处理的方式和主节点一样吗？</p>
<p>以上这些问题就是本节要解答的。</p>
<section id="rdb">
<h3>更新后的 RDB 文件<a class="headerlink" href="#rdb" title="Link to this heading">¶</a></h3>
<p>在创建新的 RDB 文件时，程序会对键进行检查，过期的键不会被写入到更新后的 RDB 文件中。</p>
<p>因此，过期键对更新后的 RDB 文件没有影响。</p>
</section>
<section id="aof">
<h3>AOF 文件<a class="headerlink" href="#aof" title="Link to this heading">¶</a></h3>
<p>在键已经过期，但是还没有被惰性删除或者定期删除之前，这个键不会产生任何影响，AOF 文件也不会因为这个键而被修改。</p>
<p>当过期键被惰性删除、或者定期删除之后，程序会向 AOF 文件追加一条 <code class="docutils literal notranslate"><span class="pre">DEL</span></code> 命令，来显式地记录该键已被删除。</p>
<p>举个例子，
如果客户端使用 <code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">message</span></code> 试图访问 <code class="docutils literal notranslate"><span class="pre">message</span></code> 键的值，
但 <code class="docutils literal notranslate"><span class="pre">message</span></code> 已经过期了，
那么服务器执行以下三个动作：</p>
<ol class="arabic simple">
<li><p>从数据库中删除 <code class="docutils literal notranslate"><span class="pre">message</span></code> ；</p></li>
<li><p>追加一条 <code class="docutils literal notranslate"><span class="pre">DEL</span> <span class="pre">message</span></code> 命令到 AOF 文件；</p></li>
<li><p>向客户端返回 <code class="docutils literal notranslate"><span class="pre">NIL</span></code> 。</p></li>
</ol>
</section>
<section id="id21">
<h3>AOF 重写<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h3>
<p>和 RDB 文件类似，
当进行 AOF 重写时，
程序会对键进行检查，
过期的键不会被保存到重写后的 AOF 文件。</p>
<p>因此，过期键对重写后的 AOF 文件没有影响。</p>
</section>
<section id="id22">
<h3>复制<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h3>
<p>当服务器带有附属节点时，
过期键的删除由主节点统一控制：</p>
<ul class="simple">
<li><p>如果服务器是主节点，那么它在删除一个过期键之后，会显式地向所有附属节点发送一个 <code class="docutils literal notranslate"><span class="pre">DEL</span></code> 命令。</p></li>
<li><p>如果服务器是附属节点，那么当它碰到一个过期键的时候，它会向程序返回键已过期的回复，但并不真正的删除过期键。因为程序只根据键是否已经过期、而不是键是否已经被删除来决定执行流程，所以这种处理并不影响命令的正确执行结果。当接到从主节点发来的 <code class="docutils literal notranslate"><span class="pre">DEL</span></code> 命令之后，附属节点才会真正的将过期键删除掉。</p></li>
</ul>
<p>附属节点不自主对键进行删除是为了和主节点的数据保持绝对一致，
因为这个原因，
当一个过期键还存在于主节点时，这个键在所有附属节点的副本也不会被删除。</p>
<p>这种处理机制对那些使用大量附属节点，并且带有大量过期键的应用来说，可能会造成一部分内存不能立即被释放，但是，因为过期键通常很快会被主节点发现并删除，所以这实际上也算不上什么大问题。</p>
</section>
</section>
<section id="db-expand-and-shrink">
<span id="id23"></span><h2>数据库空间的收缩和扩展<a class="headerlink" href="#db-expand-and-shrink" title="Link to this heading">¶</a></h2>
<p>因为数据库空间是由字典来实现的，
所以数据库空间的扩展/收缩规则和字典的扩展/收缩规则完全一样，
具体的信息可以参考《<a class="reference internal" href="../internal-datastruct/dict.html#dict-chapter"><span class="std std-ref">字典</span></a>》章节。</p>
<p>因为对字典进行收缩的时机是由使用字典的程序决定的，
所以 Redis 使用 <code class="docutils literal notranslate"><span class="pre">redis.c/tryResizeHashTables</span></code> 函数来检查数据库所使用的字典是否需要进行收缩：
每次 <code class="docutils literal notranslate"><span class="pre">redis.c/serverCron</span></code> 函数运行的时候，
这个函数都会被调用。</p>
<p><code class="docutils literal notranslate"><span class="pre">tryResizeHashTables</span></code> 函数的完整定义如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*
 * 对服务器中的所有数据库键空间字典、以及过期时间字典进行检查，
 * 看是否需要对这些字典进行收缩。
 *
 * 如果字典的使用空间比率低于 REDIS_HT_MINFILL
 * 那么将字典的大小缩小，让 USED/BUCKETS 的比率 &lt;= 1
 */
void tryResizeHashTables(void) {
    int j;

    for (j = 0; j &lt; server.dbnum; j++) {

        // 缩小键空间字典
        if (htNeedsResize(server.db[j].dict))
            dictResize(server.db[j].dict);

        // 缩小过期时间字典
        if (htNeedsResize(server.db[j].expires))
            dictResize(server.db[j].expires);
    }
}
</pre></div>
</div>
</section>
<section id="id24">
<h2>小结<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>数据库主要由 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 和 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 两个字典构成，其中 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 保存键值对，而 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 则保存键的过期时间。</p></li>
<li><p>数据库的键总是一个字符串对象，而值可以是任意一种 Redis 数据类型，包括字符串、哈希、集合、列表和有序集。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expires</span></code> 的某个键和 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 的某个键共同指向同一个字符串对象，而 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 键的值则是该键以毫秒计算的 UNIX 过期时间戳。</p></li>
<li><p>Redis 使用惰性删除和定期删除两种策略来删除过期的键。</p></li>
<li><p>更新后的 RDB 文件和重写后的 AOF 文件都不会保留已经过期的键。</p></li>
<li><p>当一个过期键被删除之后，程序会追加一条新的 <code class="docutils literal notranslate"><span class="pre">DEL</span></code> 命令到现有 AOF 文件末尾。</p></li>
<li><p>当主节点删除一个过期键之后，它会显式地发送一条 <code class="docutils literal notranslate"><span class="pre">DEL</span></code> 命令到所有附属节点。</p></li>
<li><p>附属节点即使发现过期键，也不会自作主张地删除它，而是等待主节点发来 <code class="docutils literal notranslate"><span class="pre">DEL</span></code> 命令，这样可以保证主节点和附属节点的数据总是一致的。</p></li>
<li><p>数据库的 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 字典和 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 字典的扩展策略和普通字典一样。它们的收缩策略是：当节点的填充百分比不足 10% 时，将可用节点数量减少至大于等于当前已用节点数量。</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="sphinx-toc sphinxlocaltoc">
    <h3><a href="../index.html">Page contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">数据库</a><ul>
<li><a class="reference internal" href="#id2">数据库的结构</a></li>
<li><a class="reference internal" href="#id3">数据库的切换</a></li>
<li><a class="reference internal" href="#id4">数据库键空间</a></li>
<li><a class="reference internal" href="#id5">键空间的操作</a><ul>
<li><a class="reference internal" href="#id6">添加新键</a></li>
<li><a class="reference internal" href="#id7">删除键</a></li>
<li><a class="reference internal" href="#id8">更新键</a></li>
<li><a class="reference internal" href="#id9">取值</a></li>
<li><a class="reference internal" href="#id10">其他操作</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">键的过期时间</a></li>
<li><a class="reference internal" href="#id12">过期时间的保存</a></li>
<li><a class="reference internal" href="#id13">设置生存时间</a></li>
<li><a class="reference internal" href="#id14">过期键的判定</a></li>
<li><a class="reference internal" href="#id15">过期键的清除</a><ul>
<li><a class="reference internal" href="#id16">定时删除</a></li>
<li><a class="reference internal" href="#id17">惰性删除</a></li>
<li><a class="reference internal" href="#id18">定期删除</a></li>
<li><a class="reference internal" href="#redis">Redis 使用的策略</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">过期键的惰性删除策略</a></li>
<li><a class="reference internal" href="#id20">过期键的定期删除策略</a></li>
<li><a class="reference internal" href="#aof-rdb">过期键对 AOF 、RDB 和复制的影响</a><ul>
<li><a class="reference internal" href="#rdb">更新后的 RDB 文件</a></li>
<li><a class="reference internal" href="#aof">AOF 文件</a></li>
<li><a class="reference internal" href="#id21">AOF 重写</a></li>
<li><a class="reference internal" href="#id22">复制</a></li>
</ul>
</li>
<li><a class="reference internal" href="#db-expand-and-shrink">数据库空间的收缩和扩展</a></li>
<li><a class="reference internal" href="#id24">小结</a></li>
</ul>
</li>
</ul>

  </div>
  <div class="sphinxprev">
    <h4>Previous page</h4>
    <p class="topless"><a href="../feature/slowlog.html"
                          title="Previous page">&larr; 慢查询日志</a></p>
  </div>
  <div class="sphinxnext">
    <h4>Next page</h4>
    <p class="topless"><a href="rdb.html"
                          title="Next page">&rarr; RDB</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/internal/db.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="rdb.html" title="RDB"
             >下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../feature/slowlog.html" title="慢查询日志"
             >上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">RedisBookOrigin 1.0 文档</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">数据库</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
    &#169; 版权所有 2024, 黄健宏.
      由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6创建。
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>